#!/usr/local/bin/lua

local params = select(1, ...)
if type(params) ~= "table" then
  print("Stop running it from this directory, moron!")
  os.exit(1)
end

require "luarocks.loader"
require "ursa"

function token_literal(name, data)
  ursa.token.rule{name, "!" .. data, function () return data end}
end

params.targets = ursa.util.cli_parameter_parse{unpack(params.targets)}

assert(params.font, "choose a font, you dumbass")

local noluajit = params.noluajit
do
  local newtargets = {}
  for _, v in pairs(params.targets) do
    if v == "noluajit" then
      noluajit = true
    else
      table.insert(newtargets, v)
    end
  end
  params.targets = newtargets
end

params.midname = params.longname:gsub("[^%w]", "")


local glop
if true then
  glop = ursa.embed{"glorp/glop", "Den", {{platform = params.platform}}}
else
  glop = {os = params.platform, headers = {}, lib = {}}
end


local platform = params.platform or glop.os

local builddir_pre = "build/" .. platform
ursa.token.rule{"builddir", "!" .. builddir_pre, function () return builddir_pre end}
local builddir = builddir_pre .. "/"

local osd = assert(loadfile("glorp/Den_" .. platform .. ".lua")){name = params.name, longname = params.longname, midname = params.midname, glop = glop, builddir = builddir}

if platform == "osx" then noluajit = true end   -- temporary hack for luajitb4


-- this will contain all the libs that got built from glop
local libs = {}
for k, v in pairs(glop.libs) do
  libs[k] = v
end

local libcflags = glop.libcflags
local libldflags = glop.libcflags

-- first we build the lua
local lua_headers = {}
do
  do
    if not osd.noluajit and not noluajit then
      local path = "glorp/libs/LuaJIT-2.0.0-beta4/"
      ursa.token.rule{"lua_files", "!" .. path, function () return ursa.system{("cd %s && find . -type f | sed s*\\\\./**"):format(path)} end}
      local copied = {}
      for k in ursa.token{"lua_files"}:gmatch("([^\n]+)") do
        if k == "src/Makefile" then
          -- let's make some changes
          table.insert(copied, ursa.rule{builddir .. "lib_build/lua/" .. k, path .. k, ursa.util.system_template{([[
            sed
              -e "s@CC= gcc@CC= %s@"
              -e "s/.XCFLAGS+= -DLUA_USE_APICHECK/XCFLAGS+= -DLUA_USE_APICHECK/"
              -e "s/.XCFLAGS+= -DLUA_USE_ASSERT/XCFLAGS+= -DLUA_USE_ASSERT/"
              -e "s/.BUILDMODE= static/BUILDMODE= static/"
              -e "s/.CC= gcc -m32/CC= gcc -m32/" 
              -e "s/HOST_RM= del/# HOST_RM= del/" ]] ..
              
              [[ -e "s/.XCFLAGS+= -DLUAJIT_DISABLE_JIT/XCFLAGS+= -DLUAJIT_DISABLE_JIT/" ]] --[[ This segment should be commented out if you want the jit to actually work! ]] ..
            [[$SOURCE > $TARGET]]):format(glop.libcc):gsub("\n", " ")}})
        elseif k:match("src/buildvm_.*%.h") then
        else
          table.insert(copied, ursa.rule{builddir .. "lib_build/lua/" .. k, path .. k, ursa.util.copy{}})
        end
      end
      
      ursa.rule{builddir .. "lib_build/lua/src/libluajit.a", copied, ursa.util.system_template{("cd %slib_build/lua && make -j5"):format(builddir)}}
      ursa.rule{builddir .. "lib_release/lib/liblua.a", builddir .. "lib_build/lua/src/libluajit.a", ursa.util.copy{}}
      
      -- luajit includes it in src
      table.insert(lua_headers, ursa.rule{builddir .. "lib_release/include/lua.hpp", builddir .. "lib_build/lua/src/lua.hpp", ursa.util.copy{}})
      table.insert(lua_headers, ursa.rule{builddir .. "lib_release/include/luajit.h", builddir .. "lib_build/lua/src/luajit.h", ursa.util.copy{}})
    else
      local files = "lapi lcode ldebug ldo ldump lfunc lgc llex lmem lobject lopcodes lparser lstate lstring ltable ltm lundump lzio lcoco linit lauxlib lbaselib ldblib liolib lmathlib loslib ltablib lstrlib loadlib lvm"
      local path = "glorp/libs/lua-5.1.4/"
      
      ursa.token.rule{"lua_files", "!" .. path, function () return ursa.system{("cd %s && find src etc -type f"):format(path)} end}
      local copied = {}
      for k in ursa.token{"lua_files"}:gmatch("([^\n]+)") do
        table.insert(copied, ursa.rule{builddir .. "lib_build/lua/" .. k, path .. k, ursa.util.copy{}})
      end
      
      local luaobjects = {}
      for k in files:gmatch("([^ ]+)") do  -- yes okay hardcoded shut up
        table.insert(luaobjects, ursa.rule{builddir .. "lib_build/lua/src/" .. k .. ".o", copied, ursa.util.system_template{"#CC -O3 -fomit-frame-pointer #LUA_FLAGS -I#builddir/lib_build/lua/dynasm -Wall -x c -c -o $TARGET #builddir/lib_build/lua/src/" .. k .. ".c"}})
      end

      ursa.rule{builddir .. "lib_release/lib/liblua.a", luaobjects, ursa.util.system_template{"ar rcs $TARGET $SOURCES"}} -- wonder if this'll work right under cygwin
      
      -- base lua includes it in etc
      table.insert(lua_headers, ursa.rule{builddir .. "lib_release/include/lua.hpp", builddir .. "lib_build/lua/etc/lua.hpp", ursa.util.copy{}})
    end
  end

  libs.lua = {builddir .. "lib_release/lib/liblua.a"}
  
  for k in ("lua.h lauxlib.h lualib.h luaconf.h"):gmatch("([^ ]+)") do
    table.insert(lua_headers, ursa.rule{builddir .. "lib_release/include/" .. k, builddir .. "lib_build/lua/src/" .. k, ursa.util.copy{}})
  end
end

local luabind_headers = {}
do
  -- let's luabind it up a notch
  local path = "glorp/libs/luabind-0.9"
  
  local files = {}
  
  ursa.token.rule{"luabind_files", nil, function () return ursa.system{("cd %s && find . -type f | grep -v test | grep -v examples | sed s*\\\\./**"):format(path)} end}
  
  for item in ursa.token{"luabind_files"}:gmatch("([^\n]+)") do
    if item == "luabind/adopt_policy.hpp" then
      local sourcefile = path .. "/" .. item
      local patchfile = "glorp/libs/luabind_adopt_container.patch"
      table.insert(files, ursa.rule{builddir .. "lib_build/luabind/" .. item, {sourcefile, patchfile}, ursa.util.system_template{("cp %s $TARGET && cd %s && patch -p 1 -i ../../../../%s"):format(sourcefile, builddir .. "lib_build/luabind", patchfile)}})
    else
      table.insert(files, ursa.rule{builddir .. "lib_build/luabind/" .. item, path .. "/" .. item, ursa.util.copy{}})
    end    
    
    if item:match("%.hpp$") then
      table.insert(luabind_headers, ursa.rule{builddir .. "lib_release/include/" .. item, builddir .. "lib_build/luabind/" .. item, ursa.util.copy{}})
    end
  end
  
  local objs = {}
  for item in ursa.token{"luabind_files"}:gmatch("([^\n]+)") do
    if item:match("%.cpp$") then
      table.insert(objs, ursa.rule{builddir .. "lib_build/luabind/" .. item:gsub(".cpp", ".o"), {lua_headers, luabind_headers, builddir .. "lib_build/luabind/" .. item}, ursa.util.system_template{("nice #CC -O2 -o $TARGET -c %s -I#builddir/lib_release/include -Iglorp/libs/boost #CXXFLAGS -g"):format(builddir .. "lib_build/luabind/" .. item)}})
    end
  end
  
  local luabind = builddir .. "lib_release/lib/libluabind.a"
  libs.luabind = ursa.rule{luabind, objs, ursa.util.system_template{"ar rcs $TARGET $SOURCES"}}
  
  ursa.command{"hello", libs.luabind}
end
  
local curl_headers = {}
do
  -- let's curl it up a notch
  local path = "glorp/libs/curl-7.20.0"
  
  local files = {}
  
  ursa.token.rule{"curl_files", nil, function () return ursa.system{("cd %s && (((find . -type f | grep -v CMake | grep -v docs | grep -v tests) && (find . -type f | grep Makefile)) | sed s*\\\\./** | sort | uniq)"):format(path)} end}
  for item in ursa.token{"curl_files"}:gmatch("([^\n]+)") do
    if item == "Makefile" or item == "include/curl/curlbuild.h" then
    elseif item == "Makefile.in" then
      table.insert(files, ursa.rule{builddir .. "lib_build/curl/" .. item, path .. "/" .. item, ursa.util.system_template{('sed -e "s@SUBDIRS = lib src@SUBDIRS = lib@" $SOURCE > $TARGET'):format(glop.libcc)}})
    elseif item == "include/curl/curlbuild.h.in" then
      table.insert(files, ursa.rule{builddir .. "lib_build/curl/" .. item, path .. "/" .. item, function ()
        print("stupid reparse of curlbuild.h.in")
        local fin = io.open(path .. "/" .. item, "r")
        local fout = io.open(builddir .. "lib_build/curl/" .. item, "w")
        while true do
          local lin = fin:read("*line")
          if not lin then break end
          fout:write(lin .. "\n")
          if lin == "#define __CURL_CURLBUILD_H" then
            fout:write("#define CURL_STATICLIB" .. "\n")
          end
        end
        fin:close()
        fout:close()
      end})
    elseif item == "configure"  and platform == "cygwin" then
      table.insert(files, ursa.rule{builddir .. "lib_build/curl/" .. item, path .. "/" .. item, ursa.util.system_template{([[sed
        -e "s/for sel_arg1 in/for sel_arg1 in 'int'/"
        -e "s/for sel_arg234 in/for sel_arg234 in 'fd_set *'/"
        -e "s/for sel_arg5 in/for sel_arg5 in 'const struct timeval *'/"
        -e "s/for sel_retv in/for sel_retv in 'int'/"
        
        -e "s/for recv_arg1 in/for recv_arg1 in 'SOCKET'/"
        -e "s/for recv_arg2 in/for recv_arg2 in 'char *'/"
        -e "s/for recv_arg3 in/for recv_arg3 in 'int'/"
        -e "s/for recv_arg4 in/for recv_arg4 in 'int'/"
        -e "s/for recv_retv in/for recv_retv in 'int'/"
        
        -e "s/for recvfrom_arg1 in/for recvfrom_arg1 in 'SOCKET'/"
        -e "s/for recvfrom_arg2 in/for recvfrom_arg2 in 'char *'/"
        -e "s/for recvfrom_arg3 in/for recvfrom_arg3 in 'int'/"
        -e "s/for recvfrom_arg4 in/for recvfrom_arg4 in 'int'/"
        -e "s/for recvfrom_arg5 in/for recvfrom_arg5 in 'struct sockaddr *'/"
        -e "s/for recvfrom_arg6 in/for recvfrom_arg6 in 'int *'/"
        -e "s/for recvfrom_retv in/for recvfrom_retv in 'int'/"
        
        -e "s/for send_arg1 in/for send_arg1 in 'SOCKET'/"
        -e "s/for send_arg2 in/for send_arg2 in 'const char *'/"
        -e "s/for send_arg3 in/for send_arg3 in 'int'/"
        -e "s/for send_arg4 in/for send_arg4 in 'int'/"
        -e "s/for send_retv in/for send_retv in 'int'/"
        
        $SOURCE > $TARGET && chmod +x $TARGET]]):format(glop.libcc):gsub("\n", " ")}})
    else
      table.insert(files, ursa.rule{builddir .. "lib_build/curl/" .. item, path .. "/" .. item, ursa.util.copy{}})
    end
  end
  
  local makefile = ursa.rule{{builddir .. "lib_build/curl/Makefile", builddir .. "lib_build/curl/include/curl/curlbuild.h"}, files, ursa.util.system_template{('cd %slib_build/curl && CC="%s" CFLAGS="%s" LDFLAGS="%s" ./configure --disable-shared --disable-dependency-tracking --disable-ftp --disable-file --disable-ldap --disable-ldaps --disable-rtsp --disable-proxy --disable-dict --disable-telnet --disable-tftp --disable-pop3 --disable-imap --disable-smtp --disable-manual --disable-ipv6 --disable-crypto-auth --disable-cookies'):format(builddir, glop.libcc, libcflags, libldflags)}}
  
  local lib = ursa.rule{builddir .. "lib_build/curl/lib/.libs/libcurl.a", makefile, ('cd %slib_build/curl && make'):format(builddir)}  -- can't parallelize this, libcurl is a giant butt
  
  libs.libcurl = ursa.rule{builddir .. "lib_release/lib/libcurl.a", lib, ursa.util.copy{}}
  table.insert(curl_headers, ursa.rule{builddir .. "lib_release/include/curl/curl.h", builddir .. "lib_build/curl/include/curl/curl.h", ursa.util.copy{}})
  table.insert(curl_headers, ursa.rule{builddir .. "lib_release/include/curl/curlver.h", builddir .. "lib_build/curl/include/curl/curlver.h", ursa.util.copy{}})
  table.insert(curl_headers, ursa.rule{builddir .. "lib_release/include/curl/curlbuild.h", builddir .. "lib_build/curl/include/curl/curlbuild.h", ursa.util.copy{}})
  table.insert(curl_headers, ursa.rule{builddir .. "lib_release/include/curl/curlrules.h", builddir .. "lib_build/curl/include/curl/curlrules.h", ursa.util.copy{}})
  table.insert(curl_headers, ursa.rule{builddir .. "lib_release/include/curl/easy.h", builddir .. "lib_build/curl/include/curl/easy.h", ursa.util.copy{}})
  table.insert(curl_headers, ursa.rule{builddir .. "lib_release/include/curl/multi.h", builddir .. "lib_build/curl/include/curl/multi.h", ursa.util.copy{}})
end

local fltk_headers = {}
if platform == "linux" then
  -- now let's fltk it up a notch
  local path = "glorp/libs/fltk-1.1.10"
  
  local files = {}
  
  ursa.token.rule{"fltk_files", nil, function () return ursa.system{("cd %s && find . -type f | sed s*\\\\./**"):format(path)} end}
  for item in ursa.token{"fltk_files"}:gmatch("([^\n]+)") do
    if item == "config.h" or item == "fltk.spec" or item == "fltk.list" or item == "fltk-config" then
    elseif item == "configure" then
      table.insert(files, ursa.rule{builddir .. "lib_build/fltk/" .. item, path .. "/" .. item, ursa.util.system_template{([[sed
        -e "s/-lXext//"
        
        $SOURCE > $TARGET && chmod +x $TARGET]]):format(glop.libcc):gsub("\n", " ")}})
    else
      table.insert(files, ursa.rule{builddir .. "lib_build/fltk/" .. item, path .. "/" .. item, ursa.util.copy{}})
    end
    
    
    if item:match("^FL.*") then
      table.insert(fltk_headers, ursa.rule{builddir .. "lib_release/include/" .. item, path .. "/" .. item, ursa.util.copy{}})
    end
  end
  
  ursa.token.rule{"pwd", nil, function () return ursa.system{"pwd"} end}
  
  local makefile = ursa.rule{builddir .. "lib_build/fltk/FL/Makefile", {files, glop.headers, libs.zlib, libs.libpng, libs.libjpeg}, ursa.util.system_template{('cd %slib_build/fltk && CC="%s" CFLAGS="%s" CPPFLAGS="-I%s/glorp/glop/release/linux/include -I%s/glorp/glop/release/linux/include/jpeglib" LDFLAGS="%s -L%s/glorp/glop/release/linux/lib -L/usr/lib" ./configure --disable-localjpeg --disable-localzlib --disable-localpng'):format(builddir, glop.libcc, libcflags, ursa.token{"pwd"}, ursa.token{"pwd"}, libldflags, ursa.token{"pwd"})}}
  
  local lib = ursa.rule{builddir .. "lib_build/fltk/lib/libfltk.a", makefile, ('cd %slib_build/fltk && make'):format(builddir)}
  
  libs.libfltk = ursa.rule{builddir .. "lib_release/lib/libfltk.a", lib, ursa.util.copy{}}
end

local box2d_headers = {}
if params.box2d then
  -- now let's box2d it up a notch
  local path = "glorp/libs/Box2D_v2.1.2"
  
  local files = {}
  
  ursa.token.rule{"box2d_files", nil, function () return ursa.system{("cd %s && find . -type f | sed s*\\\\./**"):format(path)} end}
  for item in ursa.token{"box2d_files"}:gmatch("([^\n]+)") do
    if item == "Build/Readme.txt" then
    else
      table.insert(files, ursa.rule{builddir .. "lib_build/box2d/" .. item, path .. "/" .. item, ursa.util.copy{}})
    end
    
    if item:match("%.h$") then
      table.insert(box2d_headers, ursa.rule{builddir .. "lib_release/include/" .. item, path .. "/" .. item, ursa.util.copy{}})
    end
  end
  
  local sedreplace = ""
  if platform == "cygwin" then
    -- cmake makes this very hard
    sedreplace = " && " .. ("sed -i -e s@/usr/bin/gcc.exe@%s@g -e s@/usr/bin/c++.exe@%s@g -e s@/cygdrive/c@c:@g `find . -type f`"):format(glop.libcc, glop.libcc)
  end
  
  local lib = ursa.rule{builddir .. "lib_build/box2d/Build/Box2D/libBox2D.a", {files}, ursa.util.system_template{('cd %slib_build/box2d/Build && CFLAGS="%s" CXXFLAGS="%s" LDFLAGS="%s -L/usr/lib" cmake -DBOX2D_INSTALL=OFF -DBOX2D_INSTALL_DOC=OFF -DBOX2D_BUILD_EXAMPLES=OFF -DCMAKE_BUILD_TYPE=Release ..' .. sedreplace .. ' && make && rmdir c\\:'):format(builddir, libcflags, libcflags, libldflags)}}
  
  libs.box2d = ursa.rule{builddir .. "lib_release/lib/libbox2d.a", lib, ursa.util.copy{}}
end

ursa.token.rule{"version", nil, ("git describe --always --match %s-* | sed s/%s-//"):format(params.name, params.name), always_rebuild = true}

local genlua = {}

ursa.rule{builddir .. "glorp/version.cpp", "#version", function ()
  print("Writing file version.cpp")
  local fil = io.open(builddir .. "glorp/version.cpp", "w")
  fil:write(([[extern const char game_version[] = "%s";]]):format(ursa.token{"version"}) .. "\n")
  fil:write(([[extern const char game_fullname[] = "%s";]]):format(params.longname) .. "\n")
  fil:write(([[extern const char game_midname[] = "%s";]]):format(params.midname) .. "\n")
  fil:write(([[extern const char game_slug[] = "%s";]]):format(params.name) .. "\n")
  fil:write(([[extern const char game_platform[] = "%s";]]):format(platform) .. "\n")
  fil:close()
end}
table.insert(genlua, ursa.rule{builddir .. "glorp/constants.lua", "!" .. params.gl_version_expected, function ()
  print("Writing file constants.lua")
  local fil = io.open(builddir .. "glorp/constants.lua", "w")
  fil:write(([[gl_version_expected = %f]]):format(params.gl_version_expected) .. "\n")
  fil:close()
end})
ursa.rule{builddir .. "glorp/main.cpp", {"!" .. params.longname, "!" .. params.font, "!" .. params.resolution[1], "!" .. params.resolution[2]}, function ()
  print("Writing file main.cpp")
  local fil = io.open(builddir .. "glorp/main.cpp", "w")
  fil:write(([[
    #include "glorp/debug.h"
    #include "glorp/core.h"

    int main(int argc, const char **argv) {
      glorp_init("%s", "%s", %d, %d, argc, argv);
    }
]]):format(params.longname, params.font, params.resolution[1], params.resolution[2]))
  fil:close()
end}

-- lgl build
local lgl_deps
do
  local lgl = ursa.embed{"glorp/lgl", "Den", {{}}}
  
  lgl.generate(ursa.absolute_from{builddir .. "glorp/lgl.cpp"}, "")
  
  lgl_deps = ursa.rule{builddir .. "glorp/lgl.h", lgl.header, ursa.util.copy{}}
end

local buildables = {
  [params.name] = {dynfiles = "main version lgl", glorpfiles = "core core_glutil core_xutil debug debug_911_on os util parse args init perfbar box2d", cfiles = "glorp/GLee", mmfiles = osd.gles and "main_iphone" or "", resources = "resource", libs = "lua luabind zlib libpng libjpeg libfreetype libfmodex glop" .. (params.box2d and " box2d" or "")},
  ["reporter"] = {dynfiles = "version", glorpfiles = "reporter_main debug_911_off os_ui os debug util parse args init", mmfiles = (platform == "osx") and "os_ui_osx" or "", libs = "zlib libcurl" .. (platform == "linux" and " libfltk" or ""), flags = "-DSUPPRESS_GLOP"},
}

local depsed = {}

local buildflags = ""
if params.box2d then
  buildflags = buildflags .. " -DGLORP_BOX2D"
end

local function build_object(src, prefix, params)
  local compiler = ursa.token{"CC"}
  if params.compiler then compiler = compiler:gsub("g%+%+", params.compiler) end
  local cli = ("%s %s -O2 -Wall -Wno-sign-compare -Wno-uninitialized -g -DDPRINTF_MARKUP %s -Iglorp -Iglorp/.. -Iglorp/libs/boost -I%sglorp -I%slib_release/include %s %s "):format(compiler, params.flags or "", buildflags, builddir, builddir, ursa.token{"CXXFLAGS"}, src)
  
  -- we *should* be doing something substantially more reliable and sane here. we're not, because this is much easier
  local clurl = (src == "glorp/reporter_main.cpp") and curl_headers or {}
  local flurl = {}
  if prefix:find("reporter") and glop.os == "linux" then
    flurl = fltk_headers
  end
  
  if not depsed[src] then
    local function make_dependencies(srcfile)
      local deps = ursa.system{cli .. "-MM"}
      deps = deps:match("^.*: (.*)$")
      
      local dependencies = {}
      for file in deps:gmatch("([^%s]+)") do
        if file ~= "\\" then
          table.insert(dependencies, file)
        end
      end
      
      return dependencies
    end
    
    local depend = src .. " dependencies"
    
    ursa.token.rule{depend, {glop.headers, lua_headers, luabind_headers, ursa.util.token_deferred{depend, default = src}, "!" .. cli, clurl, flurl, lgl_deps, box2d_headers}, function () return make_dependencies(cpp) end}
    depsed[src] = ursa.util.token_deferred{depend}
  end
  
  local dst = prefix .. "/" .. src:gsub("%.cpp", ".o"):gsub("%.c", ".o"):gsub("%.mm", ".o")
  ursa.rule{dst, {src, lua_headers, glop.headers, depsed[src], clurl, flurl, lgl_deps, box2d_headers}, ursa.util.system_template{"nice glorp/ewrap $TARGET " .. cli .. "-o $TARGET -c"}}
  return dst
end

local function build_program(name)
  local item = buildables[name]
  assert(item)
  
  local prefix = builddir .. name
  
  local objs = {}
  
  for k in (item.dynfiles or ""):gmatch("([^%s]+)") do
    table.insert(objs, build_object(builddir .. "glorp/" .. k .. ".cpp", prefix, {flags = item.flags}))
  end
  for k in (item.glorpfiles or ""):gmatch("([^%s]+)") do
    table.insert(objs, build_object("glorp/" .. k .. ".cpp", prefix, {flags = item.flags}))
  end
  for k in (item.cfiles or ""):gmatch("([^%s]+)") do
    table.insert(objs, build_object(k .. ".c", prefix, {compiler = "gcc", flags = item.flags}))
  end
  for k in (item.mmfiles or ""):gmatch("([^%s]+)") do
    table.insert(objs, build_object("glorp/" .. k .. ".mm", prefix, {flags = (item.flags or "") .. " -x objective-c++"}))
  end
  
  if platform == "cygwin" then
    for k in (item.resources or ""):gmatch("([^%s]+)") do
      local dst = (builddir .. "glorp/%s.res"):format(k)
      ursa.rule{dst, "glorp/" .. k .. ".rc", ursa.util.system_template{"nice windres $SOURCE -O coff -o $TARGET"}}
      table.insert(objs, dst)
    end
  end
  
  -- feed in all the lib files we need
  local extradeps = {}
  for v in item.libs:gmatch("([^%s]+)") do
    assert(libs[v])
    table.insert(extradeps, libs[v])
  end
  
  local sg, eg = "-Wl,--start-group", "-Wl,--end-group"
  if platform == "osx" then
    sg, eg = "", ""
  end
  
  local dst = builddir .. name .. osd.extension
  ursa.rule{dst, {objs, extradeps}, ursa.util.system_template{("nice glorp/ewrap $TARGET #CC -O2 -o $TARGET -g %s $SOURCES -L#builddir/lib_release/lib -lm #LDFLAGS %s"):format(sg, eg)}}
  return dst
end

local mainprog = build_program(params.name)
local reporter = build_program("reporter")

ursa.token.rule{"oggquality", "!6", function () return "6" end}  -- heh.

-- here is where we're generating the file list for packaging
do
  local data_deps = {}
  
  local converts = {}
  function converts.png(dst)
    return "pngcrush -brute -rem alla -cc $SOURCE $TARGET"
  end
  function converts.wav(dst)
    return "oggenc --downmix -q #oggquality -o $TARGET $SOURCE || oggenc -q #oggquality -o $TARGET $SOURCE", dst:gsub("%.wav", ".ogg")
  end
  function converts.flac(dst)
    return [[(#FLAC -d $SOURCE -c | oggenc --downmix -q #oggquality -o $TARGET -) || (#FLAC -d $SOURCE -c | oggenc -q #oggquality -o $TARGET -)]], dst:gsub("%.flac", ".ogg")
  end
  if osd.build_overrides then
    for k, v in pairs(osd.build_overrides) do
      converts[k] = v
    end
  end
  
  local function copy_a_lot(token, destprefix, sourceprefix)
    ursa.token.rule{token .. "_copy", "#" .. token .. "_files", function ()
        local data_items = {}
        for k in ursa.token{token .. "_files"}:gmatch("[^\n]+") do
          -- narsty hack for level_.lev.lua
          if params.box2d and k:match("^level_.*%.lev%.lua$") then
            local dst = destprefix .. k
            local src = sourceprefix .. k
            
            table.insert(data_items, {src = src, deps = {"glorp/tool/level_bake.lua", "glorp/util.lua", "glorp/stage_persistence.lua", "scaffold.lua", "terra.lua", "worldparams.lua"}, dst = dst, cli = "lua glorp/tool/level_bake.lua $SOURCE $TARGET 8"})
          else
            local ext = k:match("^.*%.([^%.]+)$")
            
            local dst = destprefix .. k
            local src = sourceprefix .. k
            
            local odst = dst
            
            local cli
            
            if converts[ext] then
              cli, dst = converts[ext](dst)
            end
            
            dst = dst or odst
            
            if not cli then
              cli = "cp $SOURCE $TARGET"
            end
            
            table.insert(data_items, {src = src, dst = dst, cli = cli})
          end
        end
        return data_items
      end}
    return "#" .. token .. "_copy"
  end

  -- replicate the data structure in
  ursa.token.rule{"data_files", nil, "if cd data; then find . -type f | sed s*\\\\./**; fi", always_rebuild = true}
  table.insert(data_deps, copy_a_lot("data", "data/", "data/"))

  -- resources
  ursa.token.rule{"stock_files", nil, "cd glorp/resources && ls mandible_games.png licenses.txt"}
  table.insert(data_deps, copy_a_lot("stock", "data/", "glorp/resources/"))

  -- Lua files in Glorp
  ursa.token.rule{"luaglorp_files", nil, "cd glorp && ls *.lua | grep -v Den | grep -v box2d"}
  table.insert(data_deps, copy_a_lot("luaglorp", "data/", "glorp/"))
  
  -- Box2d lua files
  if params.box2d then
    ursa.token.rule{"luabox2d_files", nil, "cd glorp && ls *.lua | grep box2d"}
    table.insert(data_deps, copy_a_lot("luabox2d", "data/", "glorp/"))
  end

  -- Lua files and font files in our core
  ursa.token.rule{"core_files", nil, "ls *.lua *.ttf *.otf | grep -v crashmelt | grep -v playtest.lev.lua", always_rebuild = true}
  table.insert(data_deps, copy_a_lot("core", "data/", ""))
  
  -- generated lua files
  ursa.token.rule{"generated_lua_files", genlua, ("cd build/%s/glorp && ls *.lua"):format(platform)}
  table.insert(data_deps, copy_a_lot("generated_lua", "data/", ("build/%s/glorp/"):format(platform)))

  ursa.token.rule{"datafiles", data_deps, function ()
    local chunks = {}
    for _, v in pairs(data_deps) do
      for _, tv in pairs(ursa.token{v:sub(2)}) do
        table.insert(chunks, tv)
      end
    end
    return chunks
  end}
  
  -- generate our actual data copies
  ursa.token.rule{"built_data", "#datafiles", function ()
    local items = {}
    for _, v in pairs(ursa.token{"datafiles"}) do
      local dst = osd.dataprefix .. v.dst
      
      local cli = v.cli
      if not cli:find("$SOURCES") then cli = cli:gsub("$SOURCE", v.src) end
      if not cli:find("$TARGETS") then cli = cli:gsub("$TARGET", dst) end
      
      table.insert(items, ursa.rule{dst, {v.src, v.deps or {}}, ursa.util.system_template{cli}})
    end
    return items
  end, always_rebuild = true}
  
  -- NOTE: this function should probably be renamed to register_cull_exceptions or something of that like, and then we actually do the culling later. right now it's sort of strange.
  function cull_data(dat)
    local path = osd.appprefix
    ursa.token.rule{"culled_data", {"#built_data"}, function ()
      local valids = {}
      for _, v in pairs(ursa.relative_from{{dat, ursa.token{"built_data"}}}) do
        local val = v:match(path:gsub("%-", "%%-") .. "(.*)")
        if not val then
          print(val, v, path:gsub("%-", "%%-") .. "(.*)")
        end
        assert(val)
        valids[val] = true
      end
      
      for f in ursa.system{("cd \"%s\" && find . -type f || true"):format(path)}:gmatch("([^\n]+)") do
        local fi = f:match("%./(.*)")
        if not valids[fi] then
          print("======== REMOVING", fi)
          ursa.system{"rm \"" .. path .. fi .. "\""}
        end
      end
      
      return "" -- alright we return nothing this is just a command basically. I need a better way to handle this.
    end, always_rebuild = true}
  end

  ursa.token.rule{"outputprefix", "#version", function ()
    return ("%s-%s"):format(params.midname, ursa.token{"version"})
  end}
end

local runnable = osd.create_runnable{mainprog = mainprog, reporter = reporter}

ursa.command{ursa.command.default, runnable.deps}

if osd.no_cli_params then
  ursa.command{"run", runnable.deps, runnable.cli}
else
  ursa.command{"run", runnable.deps, runnable.cli .. " debug"}
  ursa.command{"editor", runnable.deps, runnable.cli .. " editor"}
  ursa.command{"runclean", runnable.deps, runnable.cli}
end

ursa.command{"package", osd.installers("datafiles")}

clean_dirs = {}
table.insert(clean_dirs, "build")
table.insert(clean_dirs, "glorp/glop/build")
table.insert(clean_dirs, "glorp/glop/release")
ursa.command{"clean", function ()
  ursa.util.clean()
  for _, v in ipairs(clean_dirs) do
    ursa.system{"rm -rf " .. v}
  end
end}

ursa.build{unpack(params.targets)}
