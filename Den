#!/usr/local/bin/lua

local params = select(1, ...)
if not params then
  print("Stop running it from this directory, moron!")
  os.exit(1)
end

params.midname = params.longname:gsub("[^%w]", "")

require "luarocks.loader"
require "ursa"

clean_dirs = {}

local glop = ursa.embed{"glorp/Glop", "Den"}
local builddir_pre = "build/" .. glop.os
ursa.token.rule{"builddir", "!" .. builddir_pre, function () return builddir_pre end}
local builddir = builddir_pre .. "/"

local osd = assert(loadfile("glorp/Den_" .. glop.os .. ".lua")){name = params.name, longname = params.longname, midname = params.midname, glop = glop, builddir = builddir}

-- first we build the lua
local lua
local lua_headers = {}
do
  do
    local files = "lapi lcode ldebug ldo ldump lfunc lgc llex lmem lobject lopcodes lparser lstate lstring ltable ltm lundump lzio lcoco linit lauxlib lbaselib ldblib liolib lmathlib loslib ltablib lstrlib loadlib lvm"
    local path
    if true then
      -- luajit
      files = files .. " ljit_core ljit_mem ljit_dasm ljit_backend ljitlib"
      path = "glorp/luabuild/LuaJIT-1.1.5/"
    else
      path = "glorp/luabuild/lua-5.1.4/"
    end
    
    ursa.token.rule{"lua_files", "!" .. path, function () return ursa.util.system{("cd %s && find src -type f && (find dynasm -type f || true) "):format(path)} end}
    local copied = {}
    for k in ursa.token{"lua_files"}:gmatch("([^\n]+)") do
      table.insert(copied, ursa.rule{builddir .. "luabuild/" .. k, path .. k, ursa.util.system_template{"cp $SOURCE $TARGET"}})
    end
    
    local luaobjects = {}
    for k in files:gmatch("([^ ]+)") do  -- yes okay hardcoded shut up
      table.insert(luaobjects, (builddir .. "luabuild/src/%s.o"):format(k))
    end

    do
      local buildtype
      if glop.os == "cygwin" then buildtype = "cygwin" end
      if glop.os == "osx" then buildtype = "macosx" end
      assert(buildtype)
      ursa.rule{luaobjects, copied, ursa.util.system_template{("cd %sluabuild/src && nice make -j5 %s"):format(builddir, buildtype)}}
    end
    ursa.rule{builddir .. "lua/lib/liblua.a", luaobjects, ursa.util.system_template{"ar rcs $TARGET $SOURCES"}} -- wonder if this'll work right under cygwin
  end

  local luabuilds = {builddir .. "lua/lib/liblua.a"}
  
  for k in ("lua.h lauxlib.h lualib.h luaconf.h"):gmatch("([^ ]+)") do
    table.insert(lua_headers, ursa.rule{builddir .. "lua/include/" .. k, "glorp/luabuild/LuaJIT-1.1.5/src/" .. k, ursa.util.system_template{"cp $SOURCE $TARGET"}})
  end
  table.insert(lua_headers, ursa.rule{builddir .. "lua/include/lua.hpp", "glorp/luabuild/LuaJIT-1.1.5/etc/lua.hpp", ursa.util.system_template{"cp $SOURCE $TARGET"}})
  
  local luabindobj = {}
  local luabindroot = "glorp/luabuild/luabind-0.9ish"
  local luabindpath = luabindroot .. "/src/"
  ursa.token.rule{"luabind_source_files", nil, function () return ursa.util.system{("cd %s && ls *.cpp"):format(luabindpath)} end}
  for k in ursa.token{"luabind_source_files"}:gmatch("([^\n]+)") do
    table.insert(luabindobj, ursa.rule{builddir .. "luabind/" .. k:gsub(".cpp", ".o"), {luabuilds, luabindpath .. k}, ursa.util.system_template{("nice #CC -O2 -o $TARGET -c %s -Iglorp/%s -I#builddir/lua/include -Iglorp/luabuild/luabind-0.9ish #CXXFLAGS -g"):format(luabindpath .. k, luabindroot)}})
  end
  
  lua = builddir .. "lua/lib/libluabind.a"
  ursa.rule{lua, luabindobj, ursa.util.system_template{"ar rcs $TARGET $SOURCES"}}
  
  ursa.token.rule{"luabind_headers", nil, function () return ursa.util.system{("cd %s/luabind && find . -type f | sed s*\\\\./**"):format(luabindroot)} end}
  for item in ursa.token{"luabind_headers"}:gmatch("([^\n]+)") do
    local dest = builddir .. "lua/include/luabind/" .. item
    ursa.rule{dest, luabindroot .. "/luabind/" .. item, ursa.util.system_template{"cp $SOURCE $TARGET"}}
    table.insert(lua_headers, dest)
  end
end

ursa.token.rule{"curl_link", nil, function () return "-lcurl" end} --"curl-config --libs" seems to cause issues

ursa.token.rule{"version", nil, ("git describe --match %s-* | sed s/%s-//"):format(params.name, params.name), always_rebuild = true}

ursa.rule{"version.cpp", "#version", function ()
  print("Writing file version.cpp")
  local fil = io.open("version.cpp", "w")
  fil:write(([[extern const char game_version[] = "%s";]]):format(ursa.token{"version"}) .. "\n")
  fil:write(([[extern const char game_fullname[] = "%s";]]):format(params.longname) .. "\n")
  fil:write(([[extern const char game_midname[] = "%s";]]):format(params.midname) .. "\n")
  fil:write(([[extern const char game_slug[] = "%s";]]):format(params.name) .. "\n")
  fil:close()
end}

local buildables = {
  [params.name] = {corefiles = "main version", glorpfiles = "core debug debug_911_on os util parse args init perfbar LuaGL LuaGL_ext", cfiles = "glorp/GLee", resources = "resource"},
  ["reporter"] = {corefiles = "version", glorpfiles = "reporter_main debug_911_off os_ui os debug util parse args init"},
}

local depsed = {}

local function build_object(src, prefix, compiler)
  local cli = ("%s -O2 -Wall -Wno-sign-compare -Wno-uninitialized -g -DDPRINTF_MARKUP -I%slua/include %s %s "):format(compiler or ursa.token{"CC"}, builddir, ursa.token{"CXXFLAGS"}, src)
  if not depsed[src] then
    local function make_dependencies(srcfile)
      local deps = ursa.util.system{cli .. "-MM"}
      deps = deps:match("^.*: (.*)$")
      
      local dependencies = {}
      for file in deps:gmatch("([^%s]+)") do
        if file ~= "\\" then
          table.insert(dependencies, file)
        end
      end
      
      return dependencies
    end
    
    local depend = src .. " dependencies"
    
    ursa.token.rule{depend, {glop.headers, lua_headers, ursa.util.token_deferred{depend, default = src}}, function () return make_dependencies(cpp) end}
    depsed[src] = ursa.util.token_deferred{depend}
  end
  
  local dst = prefix .. "/" .. src:gsub("%.cpp", ".o"):gsub("%.c", ".o")
  ursa.rule{dst, {src, lua_headers, glop.headers, depsed[src]}, ursa.util.system_template{"nice glorp/ewrap $TARGET " .. cli .. "-o $TARGET -c"}}
  return dst
end

local function build_program(name)
  local item = buildables[name]
  assert(item)
  
  local prefix = builddir .. name
  
  local objs = {}
  
  for k in (item.corefiles or ""):gmatch("([^%s]+)") do
    table.insert(objs, build_object(k .. ".cpp", prefix))
  end
  for k in (item.glorpfiles or ""):gmatch("([^%s]+)") do
    table.insert(objs, build_object("glorp/" .. k .. ".cpp", prefix))
  end
  for k in (item.cfiles or ""):gmatch("([^%s]+)") do
    table.insert(objs, build_object(k .. ".c", prefix, "gcc"))
  end
  
  if glop.os == "cygwin" then
    for k in (item.resources or ""):gmatch("([^%s]+)") do
      local dst = (builddir .. "glorp/%s.res"):format(k)
      ursa.rule{dst, "glorp/" .. k .. ".rc", ursa.util.system_template{"nice windres $SOURCE -O coff -o $TARGET"}}
      table.insert(objs, dst)
    end
  end
  
  table.insert(objs, lua[1])
  
  local dst = builddir .. name .. osd.extension
  ursa.rule{dst, {objs, glop.lib, lua, "#curl_link"}, ursa.util.system_template{"nice glorp/ewrap $TARGET #CC -O2 -o $TARGET -g $SOURCES -L#builddir/lua/lib -lluabind -lm -llua -lz -lpng #curl_link #LDFLAGS"}}
  return dst
end

local mainprog = build_program(params.name)
local reporter = build_program("reporter")

local runnable = osd.create_runnable{mainprog = mainprog, reporter = reporter}

ursa.command{ursa.command.default, runnable.deps}
ursa.command{"run", runnable.deps, runnable.cli .. " debug"}
ursa.command{"runclean", runnable.deps, runnable.cli}

ursa.token.rule{"oggquality", nil, function () return "4" end}  -- heh.

-- here is where we're generating the file list for packaging
do
  local data_deps = {}
  
  local function copy_a_lot(token, destprefix, sourceprefix)
    ursa.token.rule{token .. "_copy", "#" .. token .. "_files", function ()
        local data_items = {}
        for k in ursa.token{token .. "_files"}:gmatch("[^%s]+") do
          local ext = k:match("^.*%.([^%.]+)$")
          
          local dst = destprefix .. k
          local src = sourceprefix .. k
          
          local cli
          if ext == "png" then
            cli = "pngcrush -brute -rem alla -cc $SOURCE $TARGET"
          elseif ext == "wav" then
            dst = dst:gsub("%.wav", ".ogg")
            cli = "oggenc --downmix -q #oggquality -o $TARGET $SOURCE || oggenc -q #oggquality -o $TARGET $SOURCE"
          elseif ext == "flac" then
            dst = dst:gsub("%.flac", ".ogg")
            cli = [[(/cygdrive/c/Program\ Files\ \(x86\)/FLAC/flac.exe -d $SOURCE -c | oggenc --downmix -q #oggquality -o $TARGET -) || (/cygdrive/c/Program\ Files\ \(x86\)/FLAC/flac.exe -d $SOURCE -c | oggenc -q #oggquality -o $TARGET -)]]
          else
            cli = "cp $SOURCE $TARGET"
          end
          
          table.insert(data_items, {src = src, dst = dst, cli = cli})
        end
        return data_items
      end, always_rebuild = true}
    return "#" .. token .. "_copy"
  end

  -- replicate the data structure in
  ursa.token.rule{"data_files", nil, "cd data && find . -type f | sed s*\\\\./**", always_rebuild = true}
  table.insert(data_deps, copy_a_lot("data", "data/", "data/"))

  ursa.token.rule{"stock_files", nil, "cd glorp/resources && ls mandible_games.png", always_rebuild = true}
  table.insert(data_deps, copy_a_lot("stock", "data/", "glorp/resources/"))

  -- JIT lua files
  ursa.token.rule{"jit_files", nil, "cd glorp/resources/jit && ls"}
  table.insert(data_deps, copy_a_lot("jit", "data/jit/", "glorp/resources/jit/"))

  -- Lua files in Glorp
  ursa.token.rule{"luaglorp_files", nil, "cd glorp && ls *.lua | grep -v Den"}
  table.insert(data_deps, copy_a_lot("luaglorp", "data/", "glorp/"))

  -- Lua files and font files in our core
  ursa.token.rule{"core_files", nil, "ls *.lua *.ttf"}
  table.insert(data_deps, copy_a_lot("core", "", ""))

  ursa.token.rule{"datafiles", data_deps, function ()
    local chunks = {}
    for _, v in pairs(data_deps) do
      for _, tv in pairs(ursa.token{v:sub(2)}) do
        table.insert(chunks, tv)
      end
    end
    return chunks
  end}
  
  ursa.token.rule{"outputprefix", "#version", function ()
    return ("%s-%s"):format(params.midname, ursa.token{"version"})
  end}
end

ursa.command{"package", osd.installers("datafiles")}

ursa.command{"clean", function ()
  ursa.util.clean()
  for _, v in ipairs(clean_dirs) do
    os.remove(v)
  end
end}

ursa.build{unpack(params.targets)}
