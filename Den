#!/usr/local/bin/lua

local params = select(1, ...)
if not params then
  print("Stop running it from this directory, moron!")
  os.exit(1)
end

local noluajit = params.noluajit
do
  local newtargets = {}
  for _, v in pairs(params.targets) do
    if v == "noluajit" then
      noluajit = true
    else
      table.insert(newtargets, v)
    end
  end
  params.targets = newtargets
end

params.midname = params.longname:gsub("[^%w]", "")

require "luarocks.loader"
require "ursa"

clean_dirs = {}

local glop
if true then
  glop = ursa.embed{"glorp/Glop", "Den", {{platform = params.platform}}}
else
  glop = {os = params.platform, headers = {}, lib = {}}
end

local platform = params.platform or glop.os

local builddir_pre = "build/" .. platform
ursa.token.rule{"builddir", "!" .. builddir_pre, function () return builddir_pre end}
local builddir = builddir_pre .. "/"

local osd = assert(loadfile("glorp/Den_" .. platform .. ".lua")){name = params.name, longname = params.longname, midname = params.midname, glop = glop, builddir = builddir}

-- first we build the lua
local lua
local lua_headers = {}
do
  do
    if not osd.noluajit and not noluajit then
      local path = "glorp/libs/LuaJIT-2.0.0-beta4/"
      ursa.token.rule{"lua_files", "!" .. path, function () return ursa.util.system{("cd %s && find . -type f | sed s*\\\\./**"):format(path)} end}
      local copied = {}
      for k in ursa.token{"lua_files"}:gmatch("([^\n]+)") do
        if k == "src/Makefile" then
          -- let's make some changes
          table.insert(copied, ursa.rule{builddir .. "lib_build/lua/" .. k, path .. k, ursa.util.system_template{([[
            sed
              -e "s@CC= gcc@CC= %s@"
              -e "s/.XCFLAGS+= -DLUA_USE_APICHECK/XCFLAGS+= -DLUA_USE_APICHECK/"
              -e "s/.XCFLAGS+= -DLUA_USE_ASSERT/XCFLAGS+= -DLUA_USE_ASSERT/"
              -e "s/.BUILDMODE= static/BUILDMODE= static/"
              -e "s/.CC= gcc -m32/CC= gcc -m32/" 
              -e "s/HOST_RM= del/# HOST_RM= del/" ]] ..
              
              [[ -e "s/.XCFLAGS+= -DLUAJIT_DISABLE_JIT/XCFLAGS+= -DLUAJIT_DISABLE_JIT/" ]] --[[ This segment should be commented out if you want the jit to actually work! ]] ..
            [[$SOURCE > $TARGET]]):format(glop.libcc):gsub("\n", " ")}})
        else
          table.insert(copied, ursa.rule{builddir .. "lib_build/lua/" .. k, path .. k, ursa.util.copy{}})
        end
      end
      
      ursa.rule{builddir .. "lib_build/lua/src/libluajit.a", copied, ursa.util.system_template{("cd %slib_build/lua && make -j5"):format(builddir)}}
      ursa.rule{builddir .. "lib_release/lib/liblua.a", builddir .. "lib_build/lua/src/libluajit.a", ursa.util.copy{}}
      
      -- luajit includes it in src
      table.insert(lua_headers, ursa.rule{builddir .. "lib_release/include/lua.hpp", builddir .. "lib_build/lua/src/lua.hpp", ursa.util.copy{}})
      table.insert(lua_headers, ursa.rule{builddir .. "lib_release/include/luajit.h", builddir .. "lib_build/lua/src/luajit.h", ursa.util.copy{}})
    else
      local files = "lapi lcode ldebug ldo ldump lfunc lgc llex lmem lobject lopcodes lparser lstate lstring ltable ltm lundump lzio lcoco linit lauxlib lbaselib ldblib liolib lmathlib loslib ltablib lstrlib loadlib lvm"
      local path = "glorp/libs/lua-5.1.4/"
      
      ursa.token.rule{"lua_files", "!" .. path, function () return ursa.util.system{("cd %s && find src etc -type f"):format(path)} end}
      local copied = {}
      for k in ursa.token{"lua_files"}:gmatch("([^\n]+)") do
        table.insert(copied, ursa.rule{builddir .. "lib_build/lua/" .. k, path .. k, ursa.util.copy{}})
      end
      
      local luaobjects = {}
      for k in files:gmatch("([^ ]+)") do  -- yes okay hardcoded shut up
        table.insert(luaobjects, ursa.rule{builddir .. "lib_build/lua/src/" .. k .. ".o", copied, ursa.util.system_template{"#CC -O3 -fomit-frame-pointer #LUA_FLAGS -I#builddir/lib_build/lua/dynasm -Wall -x c -c -o $TARGET #builddir/lib_build/lua/src/" .. k .. ".c"}})
      end

      ursa.rule{builddir .. "lib_release/lib/liblua.a", luaobjects, ursa.util.system_template{"ar rcs $TARGET $SOURCES"}} -- wonder if this'll work right under cygwin
      
      -- base lua includes it in etc
      table.insert(lua_headers, ursa.rule{builddir .. "lib_release/include/lua.hpp", builddir .. "lib_build/lua/etc/lua.hpp", ursa.util.copy{}})
    end
  end

  local luabuilds = {builddir .. "lib_release/lib/liblua.a"}
  
  for k in ("lua.h lauxlib.h lualib.h luaconf.h"):gmatch("([^ ]+)") do
    table.insert(lua_headers, ursa.rule{builddir .. "lib_release/include/" .. k, builddir .. "lib_build/lua/src/" .. k, ursa.util.copy{}})
  end
  
  
  local luabindobj = {}
  local luabindroot = "glorp/libs/luabind-0.9"
  local luabindpath = luabindroot .. "/src/"
  ursa.token.rule{"luabind_source_files", nil, function () return ursa.util.system{("cd %s && ls *.cpp"):format(luabindpath)} end}
  for k in ursa.token{"luabind_source_files"}:gmatch("([^\n]+)") do
    table.insert(luabindobj, ursa.rule{builddir .. "lib_build/luabind/" .. k:gsub(".cpp", ".o"), {luabuilds, luabindpath .. k}, ursa.util.system_template{("nice #CC -O2 -o $TARGET -c %s -Iglorp/%s -I#builddir/lib_release/include -Iglorp/libs/luabind-0.9ish -Iglorp/libs/boost #CXXFLAGS -g"):format(luabindpath .. k, luabindroot)}})
  end
  
  lua = builddir .. "lib_release/lib/libluabind.a"
  ursa.rule{lua, luabindobj, ursa.util.system_template{"ar rcs $TARGET $SOURCES"}}
  
  ursa.token.rule{"luabind_headers", nil, function () return ursa.util.system{("cd %s/luabind && find . -type f | sed s*\\\\./**"):format(luabindroot)} end}
  for item in ursa.token{"luabind_headers"}:gmatch("([^\n]+)") do
    table.insert(lua_headers, ursa.rule{builddir .. "lib_release/include/luabind/" .. item, luabindroot .. "/luabind/" .. item, ursa.util.copy{}})
  end
end

-- this will contain all the libs that got built from glop
local libs = {}
for k, v in pairs(glop.libs) do
  libs[k] = v
end

local curl_headers = {}
if not osd.nocurl then
  -- let's curl it up a notch
  local path = "glorp/libs/curl-7.20.0"
  
  local files = {}
  
  ursa.token.rule{"curl_files", nil, function () return ursa.util.system{("cd %s && find . -type f | sed s*\\\\./**"):format(path)} end}
  for item in ursa.token{"curl_files"}:gmatch("([^\n]+)") do
    if item == "Makefile" or item == "include/curl/curlbuild.h" then
    elseif item == "Makefile.in" then
      table.insert(files, ursa.rule{builddir .. "lib_build/curl/" .. item, path .. "/" .. item, ursa.util.system_template{('sed -e "s@SUBDIRS = lib src@SUBDIRS = lib@" $SOURCE > $TARGET'):format(glop.libcc)}})
    elseif item == "include/curl/curlbuild.h.in" then
      table.insert(files, ursa.rule{builddir .. "lib_build/curl/" .. item, path .. "/" .. item, function ()
        print("stupid reparse of curlbuild.h.in")
        local fin = io.open(path .. "/" .. item, "r")
        local fout = io.open(builddir .. "lib_build/curl/" .. item, "w")
        while true do
          local lin = fin:read("*line")
          if not lin then break end
          fout:write(lin .. "\n")
          if lin == "#define __CURL_CURLBUILD_H" then
            fout:write("#define CURL_STATICLIB" .. "\n")
          end
        end
        fin:close()
        fout:close()
      end})
    elseif item == "configure"  and platform == "cygwin" then
      table.insert(files, ursa.rule{builddir .. "lib_build/curl/" .. item, path .. "/" .. item, ursa.util.system_template{([[sed
        -e "s/for sel_arg1 in/for sel_arg1 in 'int'/"
        -e "s/for sel_arg234 in/for sel_arg234 in 'fd_set *'/"
        -e "s/for sel_arg5 in/for sel_arg5 in 'const struct timeval *'/"
        -e "s/for sel_retv in/for sel_retv in 'int'/"
        
        -e "s/for recv_arg1 in/for recv_arg1 in 'SOCKET'/"
        -e "s/for recv_arg2 in/for recv_arg2 in 'char *'/"
        -e "s/for recv_arg3 in/for recv_arg3 in 'int'/"
        -e "s/for recv_arg4 in/for recv_arg4 in 'int'/"
        -e "s/for recv_retv in/for recv_retv in 'int'/"
        
        -e "s/for recvfrom_arg1 in/for recvfrom_arg1 in 'SOCKET'/"
        -e "s/for recvfrom_arg2 in/for recvfrom_arg2 in 'char *'/"
        -e "s/for recvfrom_arg3 in/for recvfrom_arg3 in 'int'/"
        -e "s/for recvfrom_arg4 in/for recvfrom_arg4 in 'int'/"
        -e "s/for recvfrom_arg5 in/for recvfrom_arg5 in 'struct sockaddr *'/"
        -e "s/for recvfrom_arg6 in/for recvfrom_arg6 in 'int *'/"
        -e "s/for recvfrom_retv in/for recvfrom_retv in 'int'/"
        
        -e "s/for send_arg1 in/for send_arg1 in 'SOCKET'/"
        -e "s/for send_arg2 in/for send_arg2 in 'const char *'/"
        -e "s/for send_arg3 in/for send_arg3 in 'int'/"
        -e "s/for send_arg4 in/for send_arg4 in 'int'/"
        -e "s/for send_retv in/for send_retv in 'int'/"
        
        $SOURCE > $TARGET && chmod +x $TARGET]]):format(glop.libcc):gsub("\n", " ")}})
    else
      table.insert(files, ursa.rule{builddir .. "lib_build/curl/" .. item, path .. "/" .. item, ursa.util.copy{}})
    end
  end
  
  local makefile = ursa.rule{{builddir .. "lib_build/curl/Makefile", builddir .. "lib_build/curl/include/curl/curlbuild.h"}, files, ursa.util.system_template{('cd %s/lib_build/curl && CC="%s" CFLAGS="%s" LDFLAGS="%s" ./configure --disable-shared --disable-dependency-tracking --disable-ftp --disable-file --disable-ldap --disable-ldaps --disable-rtsp --disable-proxy --disable-dict --disable-telnet --disable-tftp --disable-pop3 --disable-imap --disable-smtp --disable-manual --disable-ipv6 --disable-crypto-auth --disable-cookies'):format(builddir, glop.libcc, glop.libcflags, glop.libldflags)}}
  
  local lib = ursa.rule{builddir .. "lib_build/curl/lib/.libs/libcurl.a", makefile, ('cd %slib_build/curl && make'):format(builddir)}  -- can't parallelize this, libcurl is a butt
  
  libs.libcurl = ursa.rule{builddir .. "lib_release/lib/libcurl.a", lib, ursa.util.copy{}}
  table.insert(curl_headers, ursa.rule{builddir .. "lib_release/include/curl/curl.h", builddir .. "lib_build/curl/include/curl/curl.h", ursa.util.copy{}})
  table.insert(curl_headers, ursa.rule{builddir .. "lib_release/include/curl/curlver.h", builddir .. "lib_build/curl/include/curl/curlver.h", ursa.util.copy{}})
  table.insert(curl_headers, ursa.rule{builddir .. "lib_release/include/curl/curlbuild.h", builddir .. "lib_build/curl/include/curl/curlbuild.h", ursa.util.copy{}})
  table.insert(curl_headers, ursa.rule{builddir .. "lib_release/include/curl/curlrules.h", builddir .. "lib_build/curl/include/curl/curlrules.h", ursa.util.copy{}})
  table.insert(curl_headers, ursa.rule{builddir .. "lib_release/include/curl/easy.h", builddir .. "lib_build/curl/include/curl/easy.h", ursa.util.copy{}})
  table.insert(curl_headers, ursa.rule{builddir .. "lib_release/include/curl/multi.h", builddir .. "lib_build/curl/include/curl/multi.h", ursa.util.copy{}})
  --table.insert(curl, ursa.rule{ -- more later
  -- copy dat shit
  token_literal("curl_link", "-lcurl")
else
  token_literal("curl_link", "")
end

ursa.token.rule{"version", nil, ("git describe --match %s-* | sed s/%s-//"):format(params.name, params.name), always_rebuild = true}

ursa.rule{"version.cpp", "#version", function ()
  print("Writing file version.cpp")
  local fil = io.open("version.cpp", "w")
  fil:write(([[extern const char game_version[] = "%s";]]):format(ursa.token{"version"}) .. "\n")
  fil:write(([[extern const char game_fullname[] = "%s";]]):format(params.longname) .. "\n")
  fil:write(([[extern const char game_midname[] = "%s";]]):format(params.midname) .. "\n")
  fil:write(([[extern const char game_slug[] = "%s";]]):format(params.name) .. "\n")
  fil:write(([[extern const char game_platform[] = "%s";]]):format(platform) .. "\n")
  fil:close()
end}

local buildables = {
  [params.name] = {corefiles = "main version", glorpfiles = "core debug debug_911_on os util parse args init perfbar LuaGL_common " .. (osd.gles and "LuaGLES" or "LuaGL LuaGL_ext"), cfiles = osd.gles and "" or "glorp/GLee", mmfiles = osd.gles and "main_iphone" or "", resources = "resource", libs = "zlib libpng libjpeg libfreetype libfmodex glop"},
  ["reporter"] = {corefiles = "version", glorpfiles = "reporter_main debug_911_off os_ui os debug util parse args init", mmfiles = (platform == "osx") and "os_ui_osx" or "", libs = "zlib libcurl", flags = "-DSUPPRESS_GLOP"},
}

local depsed = {}

local function build_object(src, prefix, params)
  local cli = ("%s %s -O2 -Wall -Wno-sign-compare -Wno-uninitialized -g -DDPRINTF_MARKUP -Iglorp/libs/boost -I%slib_release/include %s %s "):format(params.compiler or ursa.token{"CC"}, params.flags or "", builddir, ursa.token{"CXXFLAGS"}, src)
  
  -- we *should* be doing something substantially more reliable and sane here. we're not, because this is much easier
  local clurl = (src == "glorp/reporter_main.cpp") and curl_headers or {}
  
  if not depsed[src] then
    local function make_dependencies(srcfile)
      local deps = ursa.util.system{cli .. "-MM"}
      deps = deps:match("^.*: (.*)$")
      
      local dependencies = {}
      for file in deps:gmatch("([^%s]+)") do
        if file ~= "\\" then
          table.insert(dependencies, file)
        end
      end
      
      return dependencies
    end
    
    local depend = src .. " dependencies"
    
    ursa.token.rule{depend, {glop.headers, lua_headers, ursa.util.token_deferred{depend, default = src}, "!" .. cli, clurl}, function () return make_dependencies(cpp) end}
    depsed[src] = ursa.util.token_deferred{depend}
  end
  
  local dst = prefix .. "/" .. src:gsub("%.cpp", ".o"):gsub("%.c", ".o"):gsub("%.mm", ".o")
  ursa.rule{dst, {src, lua_headers, glop.headers, depsed[src], clurl}, ursa.util.system_template{"nice glorp/ewrap $TARGET " .. cli .. "-o $TARGET -c"}}
  return dst
end

local function build_program(name)
  local item = buildables[name]
  assert(item)
  
  local prefix = builddir .. name
  
  local objs = {}
  
  for k in (item.corefiles or ""):gmatch("([^%s]+)") do
    table.insert(objs, build_object(k .. ".cpp", prefix, {flags = item.flags}))
  end
  for k in (item.glorpfiles or ""):gmatch("([^%s]+)") do
    table.insert(objs, build_object("glorp/" .. k .. ".cpp", prefix, {flags = item.flags}))
  end
  for k in (item.cfiles or ""):gmatch("([^%s]+)") do
    table.insert(objs, build_object(k .. ".c", prefix, {compiler = "gcc", flags = item.flags}))
  end
  for k in (item.mmfiles or ""):gmatch("([^%s]+)") do
    table.insert(objs, build_object("glorp/" .. k .. ".mm", prefix, {flags = (item.flags or "") .. " -x objective-c++"}))
  end
  
  if platform == "cygwin" then
    for k in (item.resources or ""):gmatch("([^%s]+)") do
      local dst = (builddir .. "glorp/%s.res"):format(k)
      ursa.rule{dst, "glorp/" .. k .. ".rc", ursa.util.system_template{"nice windres $SOURCE -O coff -o $TARGET"}}
      table.insert(objs, dst)
    end
  end
  
  table.insert(objs, lua[1])
  
  -- feed in all the lib files we need
  local extradeps = {}
  for v in item.libs:gmatch("([^%s]+)") do
    assert(libs[v])
    table.insert(extradeps, libs[v])
  end
  
  local sg, eg = "-Wl,--start-group", "-Wl,--end-group"
  if platform == "osx" then
    sg, eg = "", ""
  end
  
  local dst = builddir .. name .. osd.extension
  ursa.rule{dst, {objs, lua, "#curl_link", extradeps}, ursa.util.system_template{("nice glorp/ewrap $TARGET #CC -O2 -o $TARGET -g %s $SOURCES -L#builddir/lib_release/lib -lluabind -lm -llua #curl_link #LDFLAGS %s"):format(sg, eg)}}
  return dst
end

local mainprog = build_program(params.name)
local reporter = build_program("reporter")

ursa.token.rule{"oggquality", "!6", function () return "6" end}  -- heh.

-- here is where we're generating the file list for packaging
do
  local data_deps = {}
  
  local converts = {}
  function converts.png(dst)
    return "pngcrush -brute -rem alla -cc $SOURCE $TARGET"
  end
  function converts.wav(dst)
    return "oggenc --downmix -q #oggquality -o $TARGET $SOURCE || oggenc -q #oggquality -o $TARGET $SOURCE", dst:gsub("%.wav", ".ogg")
  end
  function converts.flac(dst)
    return [[(#FLAC -d $SOURCE -c | oggenc --downmix -q #oggquality -o $TARGET -) || (#FLAC -d $SOURCE -c | oggenc -q #oggquality -o $TARGET -)]], dst:gsub("%.flac", ".ogg")
  end
  if osd.build_overrides then
    for k, v in pairs(osd.build_overrides) do
      converts[k] = v
    end
  end
  
  local function copy_a_lot(token, destprefix, sourceprefix)
    ursa.token.rule{token .. "_copy", "#" .. token .. "_files", function ()
        local data_items = {}
        for k in ursa.token{token .. "_files"}:gmatch("[^%s]+") do
          local ext = k:match("^.*%.([^%.]+)$")
          
          local dst = destprefix .. k
          local src = sourceprefix .. k
          
          local odst = dst
          
          local cli
          
          if converts[ext] then
            cli, dst = converts[ext](dst)
          end
          
          dst = dst or odst
          
          if not cli then
            cli = "cp $SOURCE $TARGET"
          end
          
          table.insert(data_items, {src = src, dst = dst, cli = cli})
        end
        return data_items
      end, always_rebuild = true}
    return "#" .. token .. "_copy"
  end

  -- replicate the data structure in
  ursa.token.rule{"data_files", nil, "if cd data; then find . -type f | sed s*\\\\./**; fi", always_rebuild = true}
  table.insert(data_deps, copy_a_lot("data", "data/", "data/"))

  ursa.token.rule{"stock_files", nil, "cd glorp/resources && ls mandible_games.png"}
  table.insert(data_deps, copy_a_lot("stock", "data/", "glorp/resources/"))

  -- Lua files in Glorp
  ursa.token.rule{"luaglorp_files", nil, "cd glorp && ls *.lua | grep -v Den"}
  table.insert(data_deps, copy_a_lot("luaglorp", "data/", "glorp/"))

  -- Lua files and font files in our core
  ursa.token.rule{"core_files", nil, "ls *.lua *.ttf | grep -v crashmelt | grep -v playtest.lev.lua", always_rebuild = true}
  table.insert(data_deps, copy_a_lot("core", "", ""))

  ursa.token.rule{"datafiles", data_deps, function ()
    local chunks = {}
    for _, v in pairs(data_deps) do
      for _, tv in pairs(ursa.token{v:sub(2)}) do
        table.insert(chunks, tv)
      end
    end
    return chunks
  end}
  
  ursa.token.rule{"outputprefix", "#version", function ()
    return ("%s-%s"):format(params.midname, ursa.token{"version"})
  end}
end

local runnable = osd.create_runnable{mainprog = mainprog, reporter = reporter}

ursa.command{ursa.command.default, runnable.deps}

if osd.no_cli_params then
  ursa.command{"run", runnable.deps, runnable.cli}
else
  ursa.command{"run", runnable.deps, runnable.cli .. " debug"}
  ursa.command{"editor", runnable.deps, runnable.cli .. " editor"}
  ursa.command{"runclean", runnable.deps, runnable.cli}
end

ursa.command{"package", osd.installers("datafiles")}

ursa.command{"clean", function ()
  ursa.util.clean()
  for _, v in ipairs(clean_dirs) do
    os.remove(v)
  end
end}

ursa.build{unpack(params.targets)}
